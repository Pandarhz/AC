<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Souvenirs des Écrins</title>
    
    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <!-- Font Awesome (pour les personnages) -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <!-- Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;800&family=Orbitron:wght@700&family=Fredoka:wght@400;700&family=Chewy&display=swap" rel="stylesheet">

    <style>
        :root {
            --primary-color: #000000;
            --accent-color: #ff4500;
        }

        body, html {
            margin: 0;
            padding: 0;
            height: 100%;
            width: 100%;
            overflow: hidden;
            font-family: 'Montserrat', sans-serif;
            background-color: #1a1a1a;
        }

        /* --- 1. INTRO ANIMATION (Marcheurs) --- */
        #intro-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #000;
            z-index: 2000;
            display: flex;
            align-items: center;
            justify-content: center;
            animation: fadeOutIntro 1s ease-out 4s forwards; /* Disparait après 4s */
            pointer-events: none;
        }

        .walkers-container {
            position: absolute;
            bottom: 40%;
            left: -20%; /* Départ à gauche hors écran */
            display: flex;
            gap: 20px;
            animation: walkAcross 4s linear forwards;
        }

        .walker {
            font-size: 3rem;
            color: white;
            filter: drop-shadow(0 0 10px rgba(255, 255, 255, 0.5));
        }

        /* Animation de sautillement pour simuler la marche */
        .walker i {
            animation: bounce 0.5s infinite alternate ease-in-out;
        }
        .walker:nth-child(2) i { animation-delay: 0.1s; }
        .walker:nth-child(3) i { animation-delay: 0.2s; }

        /* --- 2. DIAPORAMA (Overlay) --- */
        #slideshow-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: black;
            z-index: 3000;
            display: none; /* Caché par défaut */
            align-items: center;
            justify-content: center;
        }

        #slideshow-img {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
        }

        /* pop animation applied by toggling the .pop class from JS; duration is controlled by --pop-duration */
        :root { --pop-duration: 800ms; }
        #slideshow-img.pop {
            animation: popIn var(--pop-duration) ease-out both;
        }

        /* --- 3. CARTE ET INTERFACE --- */
        #map {
            height: 100%;
            width: 100%;
            position: absolute;
            z-index: 1;
        }

        .ui-container {
            position: absolute;
            bottom: 50px;
            width: 100%;
            text-align: center;
            z-index: 1000;
            opacity: 0;
            /* Apparait après l'intro et le zoom (env 8s) */
            animation: fadeInUI 1s ease-out 8s forwards; 
            pointer-events: none; /* Pour cliquer au travers si besoin */
        }

        /* Bouton Noir */
        .start-btn {
            background-color: #000000;
            color: white;
            padding: 20px 40px;
            border-radius: 50px;
            text-decoration: none;
            font-weight: 800;
            font-family: 'Orbitron', sans-serif;
            text-transform: uppercase;
            letter-spacing: 1px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.5);
            border: 2px solid white;
            pointer-events: auto;
            cursor: pointer;
            display: inline-block;
            transition: transform 0.1s;
        }
        
        .start-btn:active {
            transform: scale(0.95);
        }
        /* Disabled state while images preload */
        .start-btn.disabled {
            opacity: 0.6;
            cursor: default;
            pointer-events: none;
            filter: grayscale(30%);
        }
        .start-btn .progress {
            display: block;
            font-size: 0.8rem;
            margin-top: 6px;
            opacity: 0.9;
        }

        /* --- KEYFRAMES --- */
        @keyframes walkAcross {
            0% { left: -20%; }
            100% { left: 120%; } /* Sort à droite */
        }

        @keyframes bounce {
            0% { transform: translateY(0); }
            100% { transform: translateY(-10px); }
        }

        @keyframes fadeOutIntro {
            to { opacity: 0; visibility: hidden; }
        }

        @keyframes fadeInUI {
            to { opacity: 1; }
        }

        @keyframes popIn {
            0% { transform: scale(0.9); opacity: 0.5; }
            100% { transform: scale(1); opacity: 1; }
        }

    </style>
</head>
<body>

    <!-- 1. Intro Animation -->
    <div id="intro-screen">
        <div class="walkers-container">
            <!-- 3 personnages -->
            <div class="walker"><i class="fa-solid fa-person-hiking"></i></div>
            <div class="walker"><i class="fa-solid fa-person-skiing"></i></div>
            <div class="walker"><i class="fa-solid fa-person-snowboarding"></i></div>
        </div>
    </div>

    <!-- 2. Diaporama Rapide -->
    <div id="slideshow-overlay">
        <img id="slideshow-img" src="" alt="Souvenir">
    </div>

    <!-- 2b. Celebration overlay (confetti + message) -->
    <div id="celebrate-overlay" style="display:none; position:fixed; inset:0; z-index:4000; align-items:center; justify-content:center;">
        <canvas id="confetti-canvas" style="position:absolute; inset:0; width:100%; height:100%;"></canvas>
        <div id="celebrate-text" style="position:relative; z-index:4001; color:#fff; font-size:4rem; font-weight:700; text-align:center; text-shadow:0 4px 20px rgba(0,0,0,0.7); font-family:'Chewy', cursive; letter-spacing: 2px;">Joyeux Anniversaire !</div>
    </div>

    <!-- 3. Interface Bouton -->
    <div class="ui-container" id="ui-layer">
        <button id="start-btn" class="start-btn disabled" onclick="launchSlideshow()" aria-disabled="true">
            <span class="label">Lancer l'exploration</span>
            <span class="progress" id="start-progress">Chargement…</span>
        </button>
    </div>

    <!-- 4. Carte -->
    <div id="map"></div>

    <!-- Audio background -->
    <audio id="bg-audio" src="./Jump (Instrumental) - Van Halen.m4a" preload="auto" loop></audio>

    <!-- Leaflet JS -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script>
        // --- CONFIGURATION ---
        // Liste de tes photos (assure-toi qu'elles sont dans le dossier avec index.html)
        // Renomme tes photos 1.jpg, 2.jpg... pour faciliter la vie !
        // J'ai mis des placeholders Unsplash pour l'exemple, REMPLACE LES NOMS ci-dessous par tes fichiers.
        const myPhotos = [
            '1.jpg', '2.png', '3.png', '4.JPG', '5.JPG',
            '6.jpg', '7.JPG', '8.JPG', '9.JPG', '10.JPG',
            '11.JPG', '12.JPG', '13.JPG', '14.JPG', '15.jpg',
            '16.jpg', '17.jpg', '18.jpg', '19.JPG', '20.JPG',
            '21.jpg', '22.jpeg', '23.JPG', '24.jpg', '25.JPG'
        ];

        // Si tu n'as pas encore mis tes photos locales, ce code utilise des images démo :
        const demoPhotos = [
           'https://images.unsplash.com/photo-1519681393784-d120267933ba',
           'https://images.unsplash.com/photo-1454496522488-7a8e488e8606',
           'https://images.unsplash.com/photo-1486870591958-9b9d0d1dda99',
           'https://images.unsplash.com/photo-1551632811-561732d1e306',
           'https://images.unsplash.com/photo-1605542058732-22f35492d192'
        ];
        
        // IMPORTANT : Change cette variable sur 'true' quand tu as mis tes vraies photos
        const useLocalPhotos = true; 

        const photosToUse = useLocalPhotos ? myPhotos : demoPhotos;

        // Coordonnées Cibles (Lac Besson)
        const targetCoords = [44.9530, 6.0974]; 

        // 1. Initialisation Carte (Vue Espace - Zoom Lointain)
        const map = L.map('map', {
            center: [46.2276, 2.2137], // Centre de la France
            zoom: 1, // Vue de très haut
            zoomControl: false,
            attributionControl: false
        });

        // Fond de carte Topographique
        L.tileLayer('https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png', {
            maxZoom: 25,
            attribution: 'OpenTopoMap'
        }).addTo(map);

        // 2. Gestion de l'arrivée (Zoom depuis l'espace)
        // L'intro dure 4s, on attend la fin pour lancer le zoom
        setTimeout(() => {
            map.flyTo(targetCoords, 13, {
                animate: true,
                duration: 9 // Le vol dure 4 secondes
            });
            
            // Une fois arrivé, on met un marqueur
            setTimeout(() => {
                L.marker(targetCoords).addTo(map)
                .bindPopup("<b>Notre Spot</b><br>Lac de la Muzelle").openPopup();
            }, 4500);

        }, 4000);

        // 3. Audio autoplay handling + preloading function
        const bgAudio = document.getElementById('bg-audio');
        let audioAutoplayBlocked = false;

        // Try to play audio on load; if blocked by browser, wait for user gesture.
        // Also start preloading photos in background and update the start button progress.
        let photosReady = false;
        let preloadLoaded = 0;
        let preloadTotal = 0;

        document.addEventListener('DOMContentLoaded', () => {
            // attempt audio autoplay
            if (bgAudio) {
                bgAudio.play().catch((err) => {
                    audioAutoplayBlocked = true;
                    console.log('Autoplay blocked, will play on user interaction.');
                });
            }

            // start preloading images silently in background
            const startBtn = document.getElementById('start-btn');
            const progressEl = document.getElementById('start-progress');
            const urls = photosToUse.map(p => './pictures/' + p);
            preloadTotal = urls.length;

            // create a small force-launch control (hidden by default)
            let forceBtn = document.getElementById('force-btn');
            if (!forceBtn) {
                forceBtn = document.createElement('button');
                forceBtn.id = 'force-btn';
                forceBtn.textContent = 'Forcer le lancement';
                forceBtn.style.marginLeft = '12px';
                forceBtn.className = 'start-btn';
                forceBtn.style.padding = '8px 14px';
                forceBtn.style.fontSize = '0.8rem';
                forceBtn.style.borderRadius = '20px';
                forceBtn.style.display = 'none';
                forceBtn.onclick = () => {
                    photosReady = true;
                    startBtn.classList.remove('disabled');
                    startBtn.removeAttribute('aria-disabled');
                    startBtn.style.pointerEvents = 'auto';
                    forceBtn.style.display = 'none';
                };
                startBtn.parentNode.appendChild(forceBtn);
            }

            // Use improved preloader with retries and longer timeout
            preloadImagesRobust(urls, {
                timeout: 120000,  // 2 minutes total
                retries: 3,       // Essayer 3 fois par image
                perImageTimeout: 10000,  // 10 secondes par image
                onProgress: (loaded, total, failedList) => {
                    preloadLoaded = loaded;
                    if (progressEl) {
                        if (failedList && failedList.length > 0) progressEl.textContent = `Chargement ${loaded}/${total} (échecs: ${failedList.length})`;
                        else progressEl.textContent = `Chargement ${loaded}/${total}`;
                    }
                    console.log(`Progression préchargement: ${loaded}/${total}`, failedList);
                }
            }).then((result) => {
                const failed = result && result.failed ? result.failed : [];
                console.log('Préchargement terminé. Images en échec:', failed);
                if (failed.length === 0) {
                    photosReady = true;
                    if (progressEl) progressEl.textContent = 'Prêt — Lancer';
                    if (startBtn) {
                        startBtn.classList.remove('disabled');
                        startBtn.removeAttribute('aria-disabled');
                        startBtn.style.pointerEvents = 'auto';
                    }
                    console.log('✓ Toutes les images prêtes!');
                } else {
                    // Some images failed after retries/timeout. Show force button and list failures.
                    if (progressEl) progressEl.textContent = `Chargement terminé — ${failed.length} image(s) en échec`;
                    forceBtn.style.display = 'inline-block';
                    console.warn('Images en échec:', failed);
                }
            }).catch((err) => {
                // Unexpected error: allow forcing but do not enable automatically
                if (progressEl) progressEl.textContent = 'Erreur pendant le préchargement';
                forceBtn.style.display = 'inline-block';
                console.error('Erreur préchargement:', err);
            });
        });

        // Robust preload: improved version with retries, per-image timeout, and overall timeout.
        // Usage: preloadImagesRobust(urls, { timeout:60000, retries:2, onProgress: (loaded,total,failedList)=>{} })
        // Resolves with { failed: [url,...] }
        function preloadImagesRobust(urls, options = {}) {
            const overallTimeout = options.timeout || 60000;
            const retries = (typeof options.retries === 'number') ? options.retries : 0;
            const perImageTimeout = options.perImageTimeout || 8000; // timeout par image
            const onProgress = options.onProgress;

            return new Promise((resolve) => {
                if (!Array.isArray(urls) || urls.length === 0) return resolve({ failed: [] });
                const total = urls.length;
                let finished = 0;
                let settled = false;
                const failed = [];
                const loaded = {}; // Track loaded images in browser cache

                const callProgress = () => {
                    if (onProgress) onProgress(finished, total, failed.slice());
                };

                // Helper to try loading one image with retries and per-image timeout
                const loadOne = (src) => new Promise((res) => {
                    const attemptPromise = () => new Promise((attemptResolve) => {
                        let done = false;
                        const img = new Image();
                        
                        img.onload = () => { 
                            if (done) return; 
                            done = true; 
                            loaded[src] = true; // Mark as loaded in cache
                            attemptResolve({ ok: true, src }); 
                        };
                        
                        img.onerror = () => { 
                            if (done) return; 
                            done = true; 
                            attemptResolve({ ok: false, src }); 
                        };
                        
                        // Per-image timeout
                        const imgTimeout = setTimeout(() => {
                            if (done) return;
                            done = true;
                            attemptResolve({ ok: false, src });
                        }, perImageTimeout);
                        
                        try { 
                            img.src = src; 
                        }
                        catch (e) { 
                            if (!done) { 
                                done = true; 
                                clearTimeout(imgTimeout);
                                attemptResolve({ ok: false, src }); 
                            } 
                        }
                    });

                    (async () => {
                        for (let a = 0; a <= retries; a++) {
                            const r = await attemptPromise();
                            if (r.ok) return res(r);
                            // Wait a bit before retrying
                            if (a < retries) await new Promise(waitResolve => setTimeout(waitResolve, 500));
                        }
                        // All attempts failed
                        return res({ ok: false, src });
                    })();
                });

                // Kick off all loads in parallel and update progress as they finish
                const loaders = urls.map(src => {
                    return loadOne(src).then(r => {
                        finished++;
                        if (!r.ok) failed.push(r.src);
                        callProgress();
                        return r;
                    }).catch(() => {
                        finished++;
                        failed.push(src);
                        callProgress();
                        return { ok: false, src };
                    });
                });

                // Overall timeout: if reached, wait for current settled loaders and resolve
                const timeoutId = setTimeout(() => {
                    if (settled) return;
                    settled = true;
                    Promise.allSettled(loaders).then(() => {
                        resolve({ failed: failed.slice() });
                    });
                }, overallTimeout);

                Promise.all(loaders).then(() => {
                    if (settled) return;
                    settled = true;
                    clearTimeout(timeoutId);
                    resolve({ failed: failed.slice() });
                }).catch(() => {
                    if (settled) return;
                    settled = true;
                    clearTimeout(timeoutId);
                    resolve({ failed: failed.slice() });
                });
            });
        }

        // 4. Fonction Diaporama Rapide (avec préchargement)
        async function launchSlideshow() {
            const ui = document.getElementById('ui-layer');
            const overlay = document.getElementById('slideshow-overlay');
            const imgElement = document.getElementById('slideshow-img');
            // If photos are not ready yet, do nothing (button should be disabled)
            if (!photosReady) {
                console.warn('Photos not ready yet, aborting slideshow');
                return;
            }

            console.log('Lancement du diaporama avec', photosToUse.length, 'images');

            // Cacher le bouton
            ui.style.opacity = '0';

            // If audio couldn't autoplay, try to play now (user gesture)
            if (audioAutoplayBlocked && bgAudio) {
                bgAudio.play().catch(() => {/* ignore */});
            }

            // Show overlay immediately
            overlay.style.display = 'flex';

            // Start slideshow (images should be cached from preload)
            const displayInterval = 800; // ms between images
            // ensure CSS variable matches the display interval for rhythm
            document.documentElement.style.setProperty('--pop-duration', displayInterval + 'ms');

            let index = 0;
            function showNextImage() {
                if (index >= photosToUse.length) {
                    endSlideshow();
                    return;
                }
                const photoPath = './pictures/' + photosToUse[index];
                console.log('Affichage image', index + 1, ':', photosToUse[index]);
                imgElement.src = photoPath;
                // restart the pop animation by toggling the class
                imgElement.classList.remove('pop');
                // force reflow to allow re-adding the class
                void imgElement.offsetWidth;
                imgElement.classList.add('pop');
                index++;
                setTimeout(showNextImage, displayInterval);
            }
            showNextImage();
        }

        // Show celebration overlay with confetti and message, then restore UI
        function showCelebration(duration = 6000) {
            const celebrate = document.getElementById('celebrate-overlay');
            const canvas = document.getElementById('confetti-canvas');
            if (!celebrate || !canvas) return;
            celebrate.style.display = 'flex';
            canvas.width = window.innerWidth * devicePixelRatio;
            canvas.height = window.innerHeight * devicePixelRatio;
            canvas.style.width = window.innerWidth + 'px';
            canvas.style.height = window.innerHeight + 'px';
            const ctx = canvas.getContext('2d');

            // simple confetti particles
            const colors = ['#ff5e5e','#ffd166','#06d6a0','#4dabf7','#c77dff'];
            const particles = [];
            const count = 200;
            for (let i=0;i<count;i++) {
                particles.push({
                    x: Math.random()*canvas.width,
                    y: Math.random()*-canvas.height,
                    vx: (Math.random()-0.5)*6,
                    vy: 2 + Math.random()*6,
                    size: 4 + Math.random()*8,
                    color: colors[Math.floor(Math.random()*colors.length)],
                    rot: Math.random()*360,
                    rotSpeed: (Math.random()-0.5)*10
                });
            }

            let start = null;
            function frame(ts) {
                if (!start) start = ts;
                const elapsed = ts - start;
                ctx.clearRect(0,0,canvas.width,canvas.height);
                ctx.save();
                ctx.scale(devicePixelRatio, devicePixelRatio);
                for (const p of particles) {
                    p.x += p.vx;
                    p.y += p.vy;
                    p.vy += 0.05; // gravity
                    p.rot += p.rotSpeed;
                    ctx.save();
                    ctx.translate(p.x/devicePixelRatio, p.y/devicePixelRatio);
                    ctx.rotate(p.rot*Math.PI/180);
                    ctx.fillStyle = p.color;
                    ctx.fillRect(-p.size/2, -p.size/2, p.size, p.size*0.6);
                    ctx.restore();
                }
                ctx.restore();
                if (elapsed < duration) requestAnimationFrame(frame);
                else {
                    // stop and hide after a little fade
                    celebrate.style.transition = 'opacity 700ms';
                    celebrate.style.opacity = '0';
                    setTimeout(() => { celebrate.style.display='none'; celebrate.style.opacity='1'; }, 800);
                }
            }
            requestAnimationFrame(frame);
        }

        function endSlideshow() {
            const overlay = document.getElementById('slideshow-overlay');
            overlay.style.display = 'none';
            // show celebration
            showCelebration(6000);
            // Réactiver les contrôles de zoom pour l'utilisateur (after celebration)
            setTimeout(() => {
                L.control.zoom({ position: 'bottomright' }).addTo(map);
            }, 6500);
        }

    </script>
</body>
</html>
